<HTML><HEAD><!--Revised: 8 Nov, 1998 By: Pieter Hintjens-->
<TITLE>Htmlpp Reference</TITLE></HEAD>
<BODY BACKGROUND="newstone.gif">
<TABLE WIDTH=100%><TR><TD ALIGN=LEFT>
 | <A HREF="/index.htm"> iMatix home page</A><BR>
 | <A HREF="index.htm"> htmlpp home page</A><BR>
 | <A href="index.htm">&lt;&lt;</A> | <A href="index2.htm">&lt;</A>
 | <A href="index4.htm">&gt;</A> | <A href="index5.htm">&gt;&gt;</A>
<TD ALIGN=RIGHT>
<IMG SRC="htmlpp1.gif" ALT="htmlpp" WIDTH=100 HEIGHT=75 ALIGN=RIGHT HSPACE=10>
<FONT SIZE=4><B>htmlpp</B><BR><FONT SIZE=2>Version 4.2a
</TABLE>
<HR>

<H2><A NAME="TOC8">Htmlpp Reference</A></H2>

<H3><A NAME="TOC9">Description</A></H3>

<P>Htmlpp is a preprocessor for HTML files, and is intended to simplify the
task of maintaining large sets of HTML documents. You provide htmlpp with a
document that is a mix of HTML-tagged text and htmlpp commands. Htmlpp
generates a set of HTML files from that document.

<H3><A NAME="TOC10">Command-line Syntax</A></H3>

<P>To run htmlpp, use the following syntax:
<PRE>htmlpp [-option...] filename ...
</PRE>
<P>Where <EM>filename</EM> is assumed to have an extension '.htp' if
necessary.  You can use these command-line options:
<UL>
<LI>The -debug option causes htmlpp to leave all its intermediate
work files lying around.
<LI>The -guru option makes htmlpp work in guru mode, which is explained in
the <A href="index3.htm#guru">guru mode</A> section.
<LI>The -env option tells htmlpp to include the current environment in the
symbol table.
<LI>The -nofunc option disables checking of intrinsic functions; this can be
useful if your input text contains Perl code (which can itself contain lots
of functions prefixed by '&'.
<LI>The -page option lets you select one or more pages to generate. If you do
not use this option, htmlpp's default action is to generate every page in
the document. You can generate the first page only by using this command:
<PRE>htmlpp -page 1 xxxx
</PRE>
You can generate a series of specific pages too:
<PRE>htmlpp -page 1,9-10,15 xxxx
</PRE>
You can also refer to page file names, instead of page numbers (but not
using the 'nn-nn' syntax:
<PRE>htmlpp -page justhis.htm,andthat.htm xxxx
</PRE>
<LI>The -set option lets you set values from the command line; these
override any default settings or settings made from within the htmlpp input.
The syntax of this option is:
<PRE>-set name=value
</PRE>
For example,
<PRE>htmlpp -set BASE=temp myfile.txt
</PRE>
Under DOS, you must enclose name=value in quotes, e.g.:
<PRE>htmlpp -set "BASE=temp" myfile.txt
</PRE>
<LI>The -charset option defines the character set used in the source file.
This is used to translate accented characters into HTML character entity
references. Valid values are 'iso-8859-1' (you can also use 'latin-1',
'unix' and 'win' as synonymous) and 'ms-dos' (use also 'dos' or 'cp850' as
synonymous).
</UL>
<P>All command line options can be shortned to their significant letters,
e.g. '-d' is the same as '-debug'.

<H3><A NAME="TOC11">Inserting Symbols</A></H3>

<P>Htmlpp replaces symbols in command lines and HTML text. You can specify a
symbol in various ways:

<DL>
<DT>$(name)
<DD>Inserts the symbol <EM>name</EM>. If it is not defined
and the multilingual symbols option is turned on (see $(USE_LANG) variable below),
htmlpp will also search for the symbol
<EM>name.xx</EM> where <EM>xx</EM> is the current language code (see $(LANG) variable below).
If none of the symbols is defined (see .define command below) you get an error message.

<DT>$(name?default)
<DD>Inserts the symbol <EM>name</EM>. If it is not defined
and the multilingual symbols option is turned on, it will also search for the symbol
<EM>name.xx</EM> where <EM>xx</EM> is the current language code. If none of the symbols
is defined, inserts the supplied default value.

<DT>$(*name)
<DD>Inserts a link for the symbol <EM>name</EM>.  This is
shorthand for:
<PRE>&lt;A HREF="$(name)"&gt;name&lt;/A&gt;.</PRE>
If the symbol is not defined
and the multilingual symbols option is turned on, it will also search for the symbol
<EM>name.xx</EM> where <EM>xx</EM> is the current language code.
Also, if <EM>name</EM> already includes a language code (e.g. $(*home.es))
which is different from the current language and the multilingual symbols option
is turned on, the HTML 4.0 &quot;hreflang=xx&quot; attribute is automatically added in
the &lt;A...&gt; tag.<BR>
If both symbols <EM>name</EM> and <EM>name.$(LANG)</EM> have an empty value, the &lt;A...&gt;
and &lt;/A&gt; tags are left-out - i.e. the link is not
active.

<DT>$(*name*attributes*)
<DD>Inserts a link for the symbol <EM>name</EM> including <EM>attributes</EM>
within the &lt;A...&gt; tag. It is useful is you are using some of
the new attributes in HTML 4.0. This is shorthand for:
<PRE>&lt;A HREF="$(name)" attributes&gt;name&lt;/A&gt;.</PRE>
If the symbol is not defined
and the multilingual symbols option is turned on, it will also search for the symbol
<EM>name.xx</EM> where <EM>xx</EM> is the current language code.
Also, if <EM>name</EM> already includes a language code (e.g. $(*home.es))
that is different from the current language and the multilingual symbols option
is turned on, the HTML 4.0 &quot;hreflang=xx&quot; attribute is automatically added in
the &lt;A...&gt; tag.<BR>
If both symbols <EM>name</EM> and <EM>name.$(LANG)</EM> have an empty value, the &lt;A...&gt;
and &lt;/A&gt; tags are left-out.

<DT>$(*name=label)
<DT>$(*name="label")
<DD>Inserts a link for the symbol <EM>name</EM>, with label as
specified. This is shorthand for:
<PRE>&lt;A HREF="$(name)"&gt;label&lt;/A&gt;.</PRE>
If the symbol is not defined
and the multilingual symbols option is turned on, it will also search for the symbol
<EM>name.xx</EM> where <EM>xx</EM> is the current language code.
Also, if <EM>name</EM> already includes a language code (e.g. $(*home.es))
that is different from the current language and the multilingual symbols option
is turned on, the HTML 4.0 &quot;hreflang=xx&quot; attribute is automatically added in
the &lt;A...&gt; tag.<BR>
If both symbols <EM>name</EM> and <EM>name.$(LANG)</EM> have an empty value, the &lt;A...&gt;
and &lt;/A&gt; tags are left-out. You can use double quotes if the
label itself contains ')' or its first character is '*'.

<DT>$(*name*attributes*=label)
<DT>$(*name*attributes*="label")
<DD>Inserts a link for the symbol <EM>name</EM>, with label as
specified, and including <EM>attributes</EM> within the &lt;A...&gt; tag.
This is shorthand for:
<PRE>&lt;A HREF="$(name)" attributes&gt;label&lt;/A&gt;.</PRE>
If the symbol is not defined
and the multilingual symbols option is turned on, it will also search for the symbol
<EM>name.xx</EM> where <EM>xx</EM> is the current language code.
Also, if <EM>name</EM> already includes a language code (e.g. $(*home.es))
that is different from the current language and the multilingual symbols option
is turned on, the HTML 4.0 &quot;hreflang=xx&quot; attribute is automatically added in
the &lt;A...&gt; tag.<BR>
If both symbols <EM>name</EM> and <EM>name.$(LANG)</EM> have an empty value, the &lt;A...&gt;
and &lt;/A&gt; tags are left-out. You can use double quotes if the
label itself contains ')'.

<DT>$(*name=)
<DD>Inserts a link for the symbol <EM>name</EM>, with the full
reference as label.  This is shorthand for:
<PRE>&lt;A HREF="$(name)"&gt;$(name)&lt;/A&gt;.</PRE>
If the symbol is not defined
and the multilingual symbols option is turned on, it will also search for the symbol
<EM>name.xx</EM> where <EM>xx</EM> is the current language code.
Also, if <EM>name</EM> already includes a language code (e.g. $(*home.es))
that is different from the current language and the multilingual symbols option
is turned on, the HTML 4.0 &quot;hreflang=xx&quot; attribute is automatically added in
the &lt;A...&gt; tag.

<DT>$(*name=*attributes*)
<DD>Inserts a link for the symbol <EM>name</EM>, with the full
reference as label, and including <EM>attributes</EM> within the
&lt;A...&gt; tag.  This is shorthand for:
<PRE>&lt;A HREF="$(name)" attributes&gt;$(name)&lt;/A&gt;.</PRE>
If the symbol is not defined
and the multilingual symbols option is turned on, it will also search for the symbol
<EM>name.xx</EM> where <EM>xx</EM> is the current language code.
Also, if <EM>name</EM> already includes a language code (e.g. $(*home.es))
that is different from the current language and the multilingual symbols option
is turned on, the HTML 4.0 &quot;hreflang=xx&quot; attribute is automatically added in
the &lt;A...&gt; tag.<BR>

<DT>&(Perl program fragment)
<DD>Replaces the symbol by the output of the specified Perl code.
The Perl code is executed using the eval command -- see your Perl
documentation if you want to use this feature.  This is how to
replace the symbol by the output of a Perl program:
&(`perl <EM>program</EM>`).  You must enclose the program fragment
in double quotes if it contains ( or ), or else escape these
characters using '\'.

<DT>&name(arguments)
<DD>Replaces the symbol by the result of an
<A href="index3.htm#intrinsic">intrinsic function</A>.  These are predefined functions
that htmlpp provides for various purposes.

<DT>%(variable)
<DD>Replaces the symbol by the value of an environment variable.
If the variable does not exist, inserts an empty value.  For
portability, always define environment variables in uppercase.

<DT>%(variable?default)
<DD>Replaces the symbol by the value of an environment variable.
If the variable does not exist, inserts the specified default value.
For portability, always define environment variables in uppercase.

<DT>\(
<DD>Replaces this by "(".  This is to 'escape' symbol definitions so
that they are not translated.

<DT>\.
<DD>Replaces this by ".".  This is to 'escape' dots so that they are
not interpreted as commands, at the start of a line.
</DL>

<P>You can define symbols in terms of symbols: $($(name)) is
quite okay, if you know what you are doing.  Htmlpp inserts
symbols from right to left in the line.

<H3><A NAME="TOC12">Types of Symbol</A></H3>

<P>Symbols are of various types
<UL>
<LI>htmlpp provides various symbols when building certain blocks
like the table of contents;
<LI>htmlpp provides various symbols containg default values that
you can redefine if necessary;
<LI>you can define symbols using the .define command;
<LI>you can define symbols using the .build anchor command.
<LI>symbols can be defined for several languages if you are running a
multilingual site.
</UL>

<H3><A NAME="TOC13">Standard Symbols</A></H3>

<P>Htmlpp provides these standard symbols for use at any point in
the document:
<DL>
<DT>$(DATE)
<DD>The date that htmlpp started, formatted as an 8-character
string: YY/MM/DD.
<DT>$(TIME)
<DD>The time that htmlpp started, formatted as an 8-character
string: HH:MM:SS.
<DT>$(DOCBASE)
<DD>The main document filename, without extension.
<DT>$(INC)
<DD>A counter, which starts at zero and is bumped-up each time you
refer to it.  I use this to number filenames, in the .page
command.  The first time you use $(INC), it is empty - i.e. "".
The second time it is "1", then "2", "3", "many", "manymany", and
"manymanymany" (joke, sorry).
<DT>$(PAGE)
<DD>After a .page command, this holds the page filename, exactly
as specified in the .page command.
<DT>$(TITLE)
<DD>After a .page command, this holds the page title.  It is nice
to use this in the header block.
<DT>$(PIPE_TITLE)
<DD>After a .pipe command, this holds the pipe title.  It is nice
to use this in the pipe_header block.
<DT>$(PASS)
<DD>Contains either 0 or 1, depending on whether htmlpp is
scanning for titles (0) or building the output files (1).
</DL>
You may want to (re)define some of these symbols:
<DL>
<DT>$(BASE)
<DD>Defined as "doc".  This is used in .page commands for
automatic filename generation.
<DT>$(EXT)
<DD>Defined as "htm", and commonly-used hot on the heels of a
$(BASE).
<DT>$(DIR)
<DD>Defined as "." and used to prefix the filename for the generated HTML
pages.
<DT>$(SILENT)
<DD>Defined as 0.  If you .define this as 1, htmlpp will try to be
a bit quieter.  When you are generating *lots* of pages, it is
easy to lose real warnings and errors amidst the information
messages.
<DT>$(LINEMAX)
<DD>Defined as 79.  Htmlpp warns if it finds longer lines.  If
you don't want to see these warnings, set it to 0.
<DT>$(DEBUG_MODE)
<DD>Has the value 1 when htmlpp is operating in debug mode, and 0
otherwise.  To use debug mode, use the -debug command-line option.
<DT>$(LANG)
<DD>A two-character code for the language that htmlpp will use
in the formatting dates subroutines. It will also be used to search for symbols of type
<EM>name.$(LANG)</EM> when multilingual variable search is activated.
Its default value is "en" for English.
Other supported languages are "es" for Spanish, "dk" for Danish, and "fr"
for French.
<DT>$(USE_LANG)
<DD>Defined as 0. If you .define this as 1, htmlpp will search multilingual
symbols of type <EM>name.$(LANG)</EM>, and will add the hreflang attribute
in &lt;A..&gt; tags when $(*name) already ends up with a .xx language code.
<DT>$(USE_RELPATH)
<DD>Defined as 0. If you .define this as 1, all $(*name) links whose URL
does not start with "http://", "ftp:", "mailto:", "./", or "../" will be
considered within-site absolute links and will be made relative.
<DT>$(Hn)
<DD>Where 'n' is 1 to 9, defines a header level number.  You would
use this to generate headers like this:
<PRE>1
1.1
1.2
1.2.1
1.2.2 ... etc.
</PRE>
Htmlpp automatically manages the numbering of header levels.  You
are, however, limited to the 'dotted number' syntax.
</DL>
Unless you use .ignore pages, these symbols are available in
header and footer blocks (you can use them elsewhere, but you'll
get warnings):
<DL>
<DT>$(FIRST_PAGE)
<DD>The filename for the first page of the document.
<DT>$(LAST_PAGE)
<DD>The filename for the last page of the document.
<DT>$(NEXT_PAGE)
<DD>The filename for the next page of the document.
<DT>$(PREV_PAGE)
<DD>The filename for the previous first page of the document.
<DT>$(FIRST_TITLE)
<DD>The title for the first page of the document.
<DT>$(LAST_TITLE)
<DD>The title for the last page of the document.
<DT>$(NEXT_TITLE)
<DD>The title for the next page of the document.
<DT>$(PREV_TITLE)
<DD>The title for the previous first page of the document.
</DL>
<P>In addition, htmlpp will include the current environment symbols
if you run it with the -env option.  You can use this (although I
don't see the utility immediately) to redefine any of the standard
symbols such as $(EXT). Remember that you can also access any of
the environment symbols using the %(...) syntax; e.g. %(PATH).

<H3><A NAME="TOC14">Htmlpp Commands</A></H3>

<P>A htmlpp command starts with a dot, in column 1, followed by a
keyword.  You can put spaces between the dot and the keyword.  To
continue the command line over the next line, end the line with a
hyphen (though you need to at least put the dot and the keyword on
the same line.  Commands can be in upper- or lower-case: .endblock
and .EndBlock are equivalent.

<P>These are the commands that htmlpp understands:

<DL>
<DT>.define <EM>symbol</EM> [<EM>value</EM>]
<DD>Define a symbol with the specified value.  The symbol name can
consist of letters, digits, -, ., and _.  The value is everything
else up to the end of the line.  If you omit the value, the
variable is un-defined.  You can redefine a variable as often as
you like simply by repeating the .define command.  Use lowercase
for your own symbols.  Predefined htmlpp symbols are uppercase.
Case is significant.  You can assign values to the built-in htmlpp
variables like INC if you want to.  In some cases this is even
useful. If you append .xx to the symbol name, where xx is a two-characters
language code, you can afterwards use the variable as $(symbol) without
writting the language code, provided $(USE_LANG)=1 and $(LANG)=xx.
You should use standardized ISO-639 <A href="http://www.oasis-open.org/cover/iso639a.html">language codes</A>.

<DT>.define <EM>symbol</EM> = <EM>expression</EM>
<DD>Evaluates the expression and stores the result in symbol.
Note that you must use '=' to evaluate an expression.  Otherwise
the expression is considered as a string and stored as-is in the
symbol.  Htmlpp passes the expression to Perl for evaluation, so
you can use any valid Perl syntax.  If you want your htmlpp files
to be portable to (future) non-Perl implementations of htmlpp,
restrict the expressions to simple arithmetic (+, -, *, /, and
parentheses).  This is an example:
<PRE>.define count = 1
.echo $(count)
.define count = $(count) + 1
.echo $(count)
</PRE>
Of course it helps to know that htmlpp will evaluate all
variables before passing the expression to Perl to work out.
So, the second .define is evaluated as '1 + 1'.  If you decide
to rely on Perl (a good bet for now), you can use the
<B>.define =</B> command to execute shell commands, e.g.:
<PRE>.if $(PASS)
.  define junk = system "rm *.htm";
.endif
</PRE>
If you append .xx to the symbol name, where xx is a two-characters
language code, you can afterwards use the variable as $(symbol) without
writting the language code, provided $(USE_LANG)=1 and $(LANG)=xx.
You should use standardized ISO-639 <A href="http://www.oasis-open.org/cover/iso639a.html">language codes</A>.

<DT>.define <EM>symbol++</EM> <EM>initial_value</EM>
<DD>Creates or re-initialises a counter with the initial value.
Each time you use the counter symbol, it is incremented.  The
$(INC) symbol is actually defined internally like this:
<PRE>.define INC++ ""</PRE>
Note that the empty string is treated as zero; the next time
the symbol will be '1'.  You can also use '--' after the symbol
name to subtract one from its value each time it is used.  You
can stick the '++' or '--' before the symbol name: then the
symbol is incremented or decremented <EM>before</EM> its value
is taken.<BR>
The .define statement is resolved as late as possible: if the
statement refers to other variables, these are inserted when
the .define'd variable is used, rather than when it is defined.
For instance if you refer to a .define'd variable in the page
header, it will be re-evaulated each time the page header is
output.

<DT>.macro [-nosplit|-noquote] <EM>name</EM> <EM>macro-body</EM>

<DD>Defines or redefines a macro. The macro body can go over several lines;
end each continuation line with '-'. When htmlpp outputs a macro, it
replaces arguments in the body with values you supply at the time. The
arguments are $1, $2, and upwards and $*, which work as follows: $1 to $n
are the first to n'th argument you supply; $* is the whole string of
arguments. If the macro body is "", the macro is given an empty body.
Otherwise, any quotes you use will be included in the macro body as-is. If
you use the -nosplit option before the macro name, the macro will only ever
have one argument, $1. Without this option, macro arguments are split on
whitespace, with quotes and apostrophes being used to group arguments. See
the section on <A href="index3.htm#macros">macros</A> for details. The -noquote option automatically
escapes quotes in the macro arguments.

<DT>.include <EM>filename</EM>
<DD>Start reading from the specified file.  You can nest .include
files as much as you like.  Htmlpp checks for circular references.
If the same file was already included earlier, htmlpp ignores the
command, like the Perl 'require' operator.  Htmlpp searches along
the LIBPATH environment variable for the file. If you specify a
filename with a full path, htmlpp won't search the LIBPATH.  If
htmlpp can't find the document using LIBPATH, it'll search PATH too.

<DT>.include <EM>filename</EM>!
<DD>Include the file in any case, like a C #include directive.

<DT>.include <EM>`command`</EM>
<DD>Execute 'command' and include the output of the command in the
generated HTML text.  The command can be any program with
arguments; it should respect any operating system conventions or
limitations.  The output text can contain htmlpp symbols in the
normal manner.  It cannot contain htmlpp commands.

<DT>.page <EM>filename</EM> = ["]<EM>title</EM>["]
<DD>Start writing a new HTML file.  The title is required.  At any
point after the .page, you can refer to $(PAGE) and $(TITLE) for
the current file name and title.  For instance, you'll often see
this:
<PRE><EM>&lt;H1&gt;</EM>$(TITLE)<EM>&lt;/H1&gt;</EM></PRE>

<DT>.page ["]<EM>title</EM>["]
<DD>Equivalent to .page $(BASE)$(INC).$(EXT) =
"<EM>title</EM>".  Just easier.

<DT>.pipe <EM>filename</EM>=<EM>title</EM>
<DD>Tells htmlpp to create a secondary file, as specified, and to send
output there as well as to the primary file specified by the last .page
command.  The .pipe command is useful when you want to send part of a HTML
page into another file, for instance to generate a small readme.htm file for
an installation.  The piped file is prefixed by the PIPE_HEADER block and
ended with the PIPE_FOOTER block, if these are defined.

<DT>.ignore header
<DD>Ignore the next header line as far as the table of contents is
concerned.  This is good for headers like &lt;H2&gt;Table of
Contents&lt;/H2&gt;.

<DT>.ignore header <EM>level</EM>
<DD>Ignores all headers with level greater or equal to level.
This is useful if a section has a lot of H3 and H4's that you
don't want in the table of contents.  Use .ignore header 99 to re
include all further headers.

<DT>.ignore pages
<DD>Ignore all .page commands except to pick-up the page titles.
Use this when you want to create a super-document.  When you use
.ignore pages, htmlpp also ignores the .build toc and .build index
commands. So, if you want a table of contents, do the .build toc
before you say .ignore pages.  You can also use .if commands to
skip blocks of text under certain conditions.

<DT>.ignore page
<DD>Ignore next .page command for any future .build index command.
This is the right way of keeping the index page itself out of the
index.  Note that the index page does take part in the general
page-to-page linking scheme provided by $(PREV_PAGE) and such.

<DT>.if <EM>expression</EM>
<DT>[.else]
<DT>.endif
<DD>If the expression returns a false value, htmlpp skips until
the .else or .endif line.  You can nest .if blocks.  An .else is
always part of the closest preceding .if.  Htmlpp passes the
expression to Perl for evaluation, so you can use any valid Perl
syntax.  If you want your htmlpp files to be portable to (future)
non-Perl implementations of htmlpp, restrict your expressions to
simple arithmetic and logical tests (&lt;, &gt;, =, etc.).
Otherwise, enjoy Perl's vast range of tests.  This is quite okay:
<PRE>.if -f myfile.htm</PRE>
An .if block must be entirely in one line.
<DD>These are some examples of .if expressions:
<PRE>.if $(number) == 0</PRE>
<PRE>.if $(number) != 1</PRE>
<PRE>.if $(number) > 2</PRE>
<PRE>.if $(string) eq "value"</PRE>
<PRE>.if $(string) ne "value"</PRE>

<DT>.block <EM>blockname</EM>
<DD>Define a piece of HTML text to be output as part of a .build
command.  You can end the .block with an .endblock or another
.block.  Htmlpp knows about these block names:
<DL>
<DT>header
<DD>Output at the start of each new HTML page; i.e. whenever you
use a .page command.

<DT>footer
<DD>Output at the end of each HTML page.

<DT>toc_open
<DD>Output at the start of a .build toc block (see below), and
whenever htmlpp decides to indent a new level.

<DT>toc_entry
<DD>Output for each entry in the table of contents.  Use these
symbols: $(TOC_HREF) - the local URL for the file and section;
$(TOC_TITLE) - the title for the section, taken from the header
line; $(TOC_LEVEL) - the table-of-contents level, 1 and higher.
<DT>toc_close
<DD>Output whenever htmlpp decides to outdent a level, and at the
end of the table of contents.

<DT>dir_open
<DD>Output at the start of a .build dir block (see below).

<DT>dir_entry
<DD>Output for each entry in a .build dir block.  Use these
symbols: $(DIR_HREF) - URL for the file; $(DIR_NAME) - the
filename, left-justified; $(DIR_EXT) - the file extension, always
put into lowercase; $(DIR_SIZE) - the file size, right-justified;
$(DIR_DATE) - the file date; $(DIR_TIME) - the file time.  You can
also use $(DIR_SIZEK) and $(DIR_SIZEM) to get the file size in
Kbytes and Mbytes, and $(DIR_HREFL) to get the URL for the file in
lowercase.

<DT>dir_close
<DD>Output at the end of a .build dir block.

<DT>index_open
<DD>Output at the start of a .build index block (see below).

<DT>index_entry
<DD>Output for each entry in a .build index block.  Use these
symbols: $(INDEX_PAGE) - the filename; $(INDEX_TITLE) - the file
title.  For compatability with earlier versions, htmlpp also
accepts the name 'index'.

<DT>index_close
<DD>Output at the end of a .build index block.

<DT>anchor
<DD>Output whenever you use a .build anchor.  Use this symbol:
$(ANCHOR) - name of anchor.
</DL>

Any other block is treated as a user-defined block and can be
output at any point using a matching .build command.

<DT>.endblock
<DD>End the previous .block.  You can end a .block with an
.endblock or a further .block command. Any other command within
a .block is interpreted when the block has been generated.

<DT>.block <EM>blockname</EM> local
<DD>You can follow the .block command by the keyword
<TT><B>local</B></TT> - this defines a block that will be used
one time only.  The <TT>local</TT> keyword applies to header,
footer, and anchor blocks.  Local blocks are used to change the
way a single page looks, without disturbing the headers and footers
of the whole document.  Typically, you would define a general
document header at the start of the document, then a local header
and footer for a specific .page.  Note that you should define the
local page footer after the .page command.  If you define a
local footer block before the first page, htmlpp handles this
correctly.

<DT>.build toc
<DD>Build table of contents for document.  Htmlpp scans the
document and all include files once to collect titles
(&lt;Hn&gt;...&lt;/Hn&gt;) and once to create the HTML pages.
Titles (&lt;Hn&gt;...&lt;/Hn&gt;) must be entirely on a single
line, or htmlpp will not find them.  You can manage the contents
of the table of contents through the .ignore header command. You
will normally use a .build toc at the start of a document.

<DT>.build dir <EM>directory</EM> [<EM>filespec</EM>...]
<DD>Build directory listing as specified.  The .build dir command
only works if you mirror the server directory on some local disk
that htmlpp can access.  This is a Good Idea in any case.  Before
you can use .build dir you must define LOCAL and SERVER.  I define
these like this:
<PRE>.define LOCAL   i:/site:
.define SERVER  http://www.imatix.com</PRE>

The directory must be relative to either of these two.  It should
start with '/' but not end with '/'.  You can specify zero or more
filenames or wildcards (htmlpp accepts * and ?, according to UNIX
rules).  If you specify no filespecs, htmlpp assumes you mean '*'.
The filespecs can include PERL regular expressions: place the
filespec between double quotes, e.g. to match all files with 'doc'
or 'txt' somewhere in the name: .build dir /pub "doc|txt".  An
example might help:
<PRE>.define .txt   Text file
.define .htm   HTML document
.define .zip   ZIP archive
.block dir_open
&lt;PRE&gt;
.block dir_entry
$(*DIR_HREF="$(DIR_NAME)") $(DIR_SIZE)  $($(DIR_EXT))
.block dir_close
&lt;/PRE&gt;
.endblock</PRE>

Note the sneaky double-derefencing of $(DIR_EXT) which translates
the file extension into a comment like 'Text file'.  I usually
stick all such .defines in a separate .include file,
filetype.def.

<DT>.build index
<DD>Build file index for document.  This is basically a list of
all pages in the document with their titles.  If you use this,
you may want to put an .ignore page before the .page that starts
the index page.  It may be useful to do a .build index inside the
footer of a page -- this is quite okay.

<DT>.build anchor <EM>anchor-name</EM>[=title]
<DD>Build an anchor definition.  This is useful.  Basically
you do a '.build anchor somename' in a document, then do a
$(*somename) or $(*somename="label") anywhere in any other
document.  Htmlpp saves anchor symbols in the file anchor.def;
otherwise anchor symbols are treated much like normal .define'd
symbols.  One difference: anchor symbols and normal symbols do not
share the same namespace; if you .define a symbol with the same
name as the anchor symbol, the .define'd symbol takes precedence.
If you undefine the symbol, the anchor symbol reappears by magic.
This may or may not be useful, but it is the way it works.  If you
change the file structure of your document, run everything through
htmlpp *TWICE*, so that all anchor references can get really
solidly updated.  You can delete the anchor.def file at any time;
it is just kept to save some context between runs.  When you use
the form $(*somename) to refer to an anchor, htmlpp will insert
the anchor title as the label.

<DT>.build <EM>user_block_name</EM>
<DD>Output the user-defined block specified.  This is any amount
of text that you do not want to specifically put into a separate
file for use with the .include command.  You define the block
using the .block command.

<DT>.echo [-] <EM>text</EM>
<DD>Echoes the text to the console.  Strips-off any leading and
trailing spaces, but you can enclose the text in single or double
quotes if you want leading/trailing spaces.  Unless you place a
hyphen before the text, htmlpp adds a newline.

<DT>.for <EM>name</EM> in <EM>item</EM>...
<DT>.endfor
<DD>Repeats the text between .for and .endfor, where $(name) has
the value of each item in the list.  The item list is separated
by spaces.

<DT>.for <EM>name</EM> in `<EM>command</EM>`
<DD>Repeats the text between .for and .endfor, where $(name) has
the value of each line in the output generated by the command.
The special variables $(1), $(2), and so on will hold each word
in the line.

<DT>.for <EM>name</EM> in @<EM>filename</EM>
<DD>Repeats the text between .for and .endfor, where $(name) has
the value of each line in the specified file.  The special variables
$(1), $(2), and so on will hold each word in the line.

<DT>.for <EM>name</EM> in %<EM>filename</EM> <EM>separator comment_flag</EM>
[<EM>orderby</EM>[&gt;]] [<EM>exact_match</EM>] [<EM>case_sensitive</EM>] [<EM>criterium</EM> ...]
<DD>Repeats the text between .for and .endfor, where $(name) has
the value of each line which satisfies the given query in the specified file,
which must be a flat-text database whose fields are separated by <EM>separator</EM>.
Use Perl conventions for the separator character, and escape backslashes with
a backslash (e.g. if the separator character is '|', you should use '\|' in
Perl, and '\\|' as <EM>separator</EM>).
The special variables $(1), $(2), and so on will hold each field in the line.<BR>
When reading the database, all lines that start with <EM>comment_flag</EM> will
be skipped. The rows resulting from the query will be sorted in ascending
order according to field number <EM>orderby</EM>, unless you append a &gt;
character to the field number, in which case they will be sorted in descending
order.<P>

Each query <EM>criterium</EM> is defined by four pipe-delimited fields. You can
use as many criteria as you want. The fields are the
<OL>
<LI>value to be matched
<LI>index of field into the database that this criteria applies to (starting at 1)
<LI>operator for comparison
	<DL><DT>Possible values: >,<,>=,<=,=,!= (not equal)
	<DD>The operator is compared the following way:
    <P><CODE>value OPERATOR database_field_value</CODE></P>
 	That is, (1) above is the left hand side of the
	operator and (2) above is the right hand side of  the operator.
</DL>
<LI>data type of the field (this determines how the operator in (3) gets
applied to the data)
    <DL><DT>The data type can be: <CODE>date</CODE>, <CODE>number</CODE>, or
	<CODE>string</CODE>
	<DD>If the data type is a date, then the operator
	for comparison is done after the value to be matched.
	Note that dates must be in <EM>MM/DD/YY</EM> format.<BR>
	If the data type is a number, then the operator
	for comparison is done based off of numerical
	if operators (>,<,==, etc.)<BR>
	If the data type is a string, then the operator
	for comparison is done based off of string
	if operators (gt, lt, eq, ne, etc.) with ONE
	EXCEPTION.<BR>
	If the datatype is a STRING *AND* the operator
	is =, then the search that is done becomes a
	more flexible search:
    <UL>
		<LI>All the words in the form variable are split
                apart and searched as separate keywords in the
                text of the fields.
		<LI> By default, the search on string = string
                is a pattern match search and is not case
                sensitive.
		<LI> If you want this special string,= combination
                searching to be case sensitive and to match on
                whole words only, you MUST set <EM>case_sensitive</EM>
                and <EM>exact_match</EM> to <CODE>on</CODE><BR>
              If <EM>exact_match</EM> is on then the
                combination of string,= in the query criteria
                array will match on WHOLE WORDS only.<BR>
              If <EM>case_sensitive</EM> is on then the
                combination of string,= in the query criteria
                array must have matching case values (upper/lower).
    </UL></DL>
</OL>
<DL>
<DT><EM>Examples:</EM>
<DD><UL><LI>&quot;20|9|<=|number&quot; &quot;40|9|>=|number&quot;: return
all rows in the database whose field number 9 value is between 20 and 40.
<LI>&quot;hello world|1,2,3,4,5|=|string&quot;: return all rows in the
database that contain the words &quot;hello&quot; <EM>and</EM> &quot;world&quot;
(in that order if <EM>exact_match</EM> is set to on, otherwise in any order)
in any of the fields from 1 to 5.
</UL>
<DT><EM>Suggestions:</EM>
<DD><UL>
<LI>You can use some of the free tools in Internet to generate flat-text
databases with and HTML interface, so that even other people can fill the
data and your pages will be generated using those data. See for example
<A href="http://www.extropia.com/products.html">Selena Sol's Database Manager</A>.
<LI>By combining the -set command-line option with this .for loop you can
automate mass-production of similar pages from a single htmlpp document.<BR>
Imagine you want to make a page for each of the employees in your company.
The employees themselves can fill their data through the web with some of
the tools mentioned above. You make a htmlpp document with something like:
<PRE>.for row in %database "\\|" "COMMENT:" "on" "on" "$(person)|1|=|string"
.page "$(5)" = "$(2) $(3)'s Homepage"
&lt;UL&gt;
    &lt;LI&gt;E-mail: &lt;A href="mailto:$(4)"&gt;$(4)&lt;/A&gt;
    &lt;LI&gt;Office: $(5)
[...]
.endfor</PRE>
Then calling 'htmlpp -set person=<EM>personcode</EM> <EM>template_file</em>'
for each person will produce his personal page.
</UL></DL>

<DT>.for <EM>name</EM> from <EM>start</EM> to <EM>end</EM>
<DD>Repeats the text between .for and .endfor, where $(name) has
a numeric value from <EM>start</EM> to <EM>end</EM> inclusive.
Htmlpp will count up or down as necessary.
</DL>

<A NAME="macros">&nbsp;</A>
<H3><A NAME="TOC15">Htmlpp Macro Processing</A></H3>

<P>Macros are a shorthand way to produce HTML tags and other
constructs.  This is how I define a macro 'H3':
<PRE>.macro H3 &lt;H3&gt;$*&lt;/H3&gt;</PRE>
<P>I use all uppercase names for macros, but this is just a
convention, since the case is not important.  We can use a macro
like H3 in three ways:
<PRE>.H3 some text</PRE>
<P>or
<PRE>&lt;!--.H3 some text--&gt;</PRE>
<P>or
<PRE>&lt;.H3 some text&gt;</PRE>
<P>The first form is good for titles and other constructs that
come naturally on a line by themselves.  Since it uses a syntax
similar to htmlpp commands, there is a certain danger that a
macro will conflict with some future command.  This is just too
bad; the alternative of inventing yet another syntax for macros
was (for me) a worse choice.  In any case, htmlpp will warn you
if you try to define a macro that already exists as a command.
The second form is compatible with HTML editors and some other
HTML preprocessors, but is frankly a pain to type. The third
form is good for mark-up tags.  The second and third forms
suffer from one problem: the whole thing has to come on a single
line.

<P>When you use a macro like this: &lt;.H3 some text&gt; you are supplying
<EM>arguments</EM>. Here we supply two, 'some' and 'text'. You can refer to
these as $1 and $2 inside the macro definition, or together as $*. Htmlpp
can handle quotes correctly, so &lt;.H3 "some text"&gt; only supplies one
argument, $1.

<P>The $+ symbol expands to anything left over after $1, $2, etc. For
instance, if you refer to $1 and $3 in the macro body, $+ refers to $4 and
any remaining arguments.

<P>The $# symbol expands to the number of macro arguments.

<P>You can define a macro with a section that repeats for each argument.
This is useful if you don't know in advance how many arguments you are going
to have. For instance, the standard .THEAD macro generates a table heading
for one, two, three, or more columns. You specify the repeating section as
{...$n...}. The text between '{' and '}' is repeated for each argument; "$n"
(dollar sign, small 'n') is replaced by the argument value.

<P>To use multi-word arguments, enclose them in quotes.

<P>When a macro refers to a variable using $(xxx), this will be
expanded as soon as the macro is expanded.  Usually this is what
you expect, but sometimes you need the variable to be expanded in
the <I>next</I> pass, for instance if you generate the .define
in the same pass.  In this case, escape the variable: $\(xxx).

<P>The file macro.def that comes with htmlpp defines a set of
standard macros.  You can define multiline macros that include
other commands, like .if and .include.

<H3><A NAME="TOC16">Multilingual support</A></H3>
<H4><A NAME="TOC17">Support For Accented Characters</A></H4>

You can type accented characters directly, and htmlpp will do
its best to convert these into HTML metacharacters.  For instance,
if your document contains an e-circumflex, htmlpp will replace it
by the metacharacter &amp;ecirc;.

<P>Supported character sets are ISO-8859-1 and MS-DOS (codepage 850).
In general you can use ISO-8859-1 both for Unix Latin-1 and Windows 1250.
You can define the character set through the -charset command-line option
or let htmlpp do a
little testing of the wind to figure-out if it's running under a
Unix or a DOS system (Windows testing not supported).
If you use htmlpp on a Mac, or on documents
encoded using another character set it won't
work.  Basically htmlpp handles MS-DOS accents if there is an
environment variable 'COMPSPEC' defined, and ISO-8859-1 accents if there
is a file called "/etc/passwd" on the system.

<P>If you use any character which is not
on ISO-8859-1 or MS-DOS CP850 you will find that it comes-out
as '?' (not found). If you have the HTML metachar for the character
(which must be a Unicode numeric reference rather than an entity reference
if it is outside ISO-8859-1) and the octal ASCII code for the character
set you are using, please send it to me.

<H4><A NAME="TOC18">Dates Formatting</A></H4>
Days of the week and month names in date formatting functions can be written
in several languages. Current supported
languages are "es" for Spanish, "dk" for Danish, and "fr" for French.
If no language is specified in the formatting function the value of
standard symbol $(LANG) is used, which is "en" by default if it has not
been redefined.

<H4><A NAME="TOC19">Multilingual Variables</A></H4>
Htmlpp allows you to add two-character "extensions" to symbols to
denote the language for the symbol value. This way you don't have to
remember different symbol names for each alternative language you offer
in your site. When you use the symbol you don't have to specify the language
if it coincides with the current value of $(LANG). This feature only works
when you activate the multiligual variable search option by defining
$(USE_LANG) to 1.
<DL><DT><EM>Example:</EM>
<DD><PRE>.define USE_LANG 1
.define home.en  "http://www.myserver.com/english/index.html"
.define home.es  "http://www.myserver.com/spanish/index.html"
.define home.fr  "http://www.myserver.com/french/index.html"</PRE>
Now if you use the symbol $(home), htmlpp will
<OL>
<LI>Look for variable $(home).
<LI>Because $(home) does not exist, look for $(home.$(LANG)).
</OL>
<P>If you want to make a link to a variable which is in a different language
than the current one in $(LANG) you can use the full symbol name and Htmlpp
will add for you the 'hreflang=xx' attribute:
<PRE>.define $(LANG)  es
$(*home=Home) --&gt;
     &lt;A href="http://www.myserver.com/spanish/index.html"&gt;Home&lt;/A&gt;
$(*home.es=Home) --&gt;
     &lt;A href="http://www.myserver.com/spanish/index.html"&gt;Home&lt;/A&gt;
$(*home.en=Home) --&gt;
     &lt;A href="http://www.myserver.com/english/index.html" hreflang=en&gt;Home&lt;/A&gt;
</PRE>
</DL>

<H4><A NAME="TOC20">Generating Several Language Versions from a Single Source File</A></H4>
<P>You can use the following trick. Write your source file as:
<PRE>
.if ("$(LANG)" eq "en")

  [... version in english ...]

.elsif ("$(LANG)" eq "es")

  [... version in spanish ...]

.elsif ("$(LANG)" eq "fr")

  [... version in french ...]

.endif
</PRE>
Then to process each language invoke htmlpp as 'htmlpp -set LANG=xx filename'.
You can also write a simple shell script to process the three languages at
once by calling three times to Htmlpp.


<A NAME="guru">&nbsp;</A>
<H3><A NAME="TOC21">Htmlpp Guru Mode</A></H3>

<P>Recognising that a True Guru does not have time to painfully
mark-up large HTML documents, htmlpp includes a basic text-to-HTML
converter.  You can invoke this as a preprocessing phase to the
normal htmlpp process.  Right now, this is an either-or choice; you
either use htmlpp commands in a HTML document, or a text document
and guru mode, but not a mixture of the two modes.  (Release 3.1 of
htmlpp tried to make this work, but that did not last long :\ )

<P>You can, usefully, use htmlpp's guru mode to mark-up a document,
then fine-tune it by hand.

<P>To use guru mode, run htmlpp with the '-guru' option:
<PRE>htmlpp -guru <I>filename</I>
</PRE>

<P>Guru mode works by recognising layout, and converting this to HTML.
I've tried to keep a balance between features and complexity, to give
you something useful without becoming too formal (which is what HTML
is for).  Basically, guru mode relies on layout rules that also help
to make the text readable in any case.  For example, blank lines and
indentation are significant in most places.  One consequence of this
is that the plain text file is very readable even before it is HTML'd
(assuming you do your bit to help things.)

<P>In guru mode, htmlpp reads an input text file (with any name and
extension except '.hpp') and creates an output file with the same name
and the extension '.hpp'.   It then processes this file as it would
any normal input file.  The '.hpp' file remains afterwards, so you can
use it as the basis for further refinement if wanted.  (You should
call it something else, to avoid embarrasing mistakes.)

<H4><A NAME="TOC22">Standard Guru Mode Definitions</A></H4>

<P>The file 'guru.def' is always inserted at the start of the
newly-created file.  You can modify this file as wanted, to tune the
results of guru mode.  You cannot choose another name for this file
other than by changing htmlpp's source code, which I don't recommend.

<P>Htmlpp looks for a file called 'guru.fmt' which may exist and which
may redefine the various HTML tags it uses.  A file 'guru_opt.fmt' is
supplied in the htmlpp distribution; rename or copy this to 'guru.fmt'
and change any values you want to (I'd suggest you remove anything that
does not change, just to make things clear).  I've made it work in
this way so that if you reinstall htmlpp, you don't loose your work.

<H4><A NAME="TOC23">Chapter and Section Headers</A></H4>
<P>Htmlpp handles three levels of headers, H1, H2, and H3.  In the text
these look like this:
<PRE>Chapter Header
**************

Section Header
==============

Subsection Header
-----------------
</PRE>

<P>The line following the header text must start with 3 or more
asterisks, equals, or hyphens.  There is no way to specify H4 or
other headers.  I recommend that you start the document with a
chapter header.

<P>You can also request a horizontal rule (&lt;HR&gt;) by putting
four or more dots on a line by themselves:
<PRE>....
</PRE>

<P>The header text line must come after a blank line, or at the start
of the document.

<H4><A NAME="TOC24">Table of Contents</A></H4>
<P>If your document contains at least two chapters, htmlpp will
insert a table of contents before the second chapter header.  This
works best if the first chapter is empty or contains a brief text
to introduce the document.  Htmlpp inserts the table of contents
by adding a section header called 'Table of Contents', and then
a line '.include contents.def', in the normal manner.  You should
not call the first chapter 'Table of Contents'.

<H4><A NAME="TOC25">Pagination</A></H4>
<P>Htmlpp inserts a '.page' command before each chapter header.
Therefore, use chapter headers wisely to break the document into
usable pages.

<H4><A NAME="TOC26">Page Headers and Footers</A></H4>
<P>The guru.def file normally includes 'prelude.def', which defines
page headers and footers for the document.  You will normally tune
these for any project -- the supplied files contain references to
iMatix URLs that may not be appropriate for your work.  I like to
use the same headers and footers (the same prelude.def) for all the
files in a project, including those I that use guru mode.

<H4><A NAME="TOC27">Paragraphs</A></H4>
<P>A paragraph is anything following a blank line that does not
look like something else.  Basically, any plain text following a
blank line is given a &lt;P&gt; tag.  Note however the exceptions
that follow...

<H4><A NAME="TOC28">Preformatted Text</A></H4>
<P>If a line is indented by 4 or more spaces, or a tab, htmlpp
treats the line as 'preformatted' text and inserts a &lt;PRE&gt;
tag.  You can mix blank lines with preformatted text.

<H4><A NAME="TOC29">Bulleted and Numbered Lists</A></H4>
<P>A paragraph starting with a hyphen and a space is considered to
be a bulleted list item.  A paragraph starting with a digit and a
dot and optionally a space is considered to be a numbered list item.
You can put blank lines between list items, but it's not necessary.
Cosmetically, when list items are short, blank lines are disturbing.
But when list items are several lines, blank lines make the text
more readable.  Either way, htmlpp is happy.

<H4><A NAME="TOC30">Definition Lists</A></H4>
<P>A definition list is a line ending in ':' followed by some lines
indented by one or more spaces.  For example:
<PRE>Definition:
 Explanation of definition.
</PRE>
<P>You can put blank lines between definition items, but again, it's
a matter of cosmetics.  There should be a blank line before the first
definition item, however.

<H4><A NAME="TOC31">Tables</A></H4>
<P>Tables are one of the real pains of HTML markup, in my opinion.
Here htmlpp tries to solve the most common case; a two-column table
consisting of a term or value in one column, and an explanation in
the second column.

<P>A table can start with a header, which is a line like this:
<PRE>Some column:  Followed by some explanation:
</PRE>

<P>Here, the colons (':') are important.  Htmlpp also wants a captial
letter at the start of both phrases, and a space after the first colon.
The table header is optional; you can start immediately with table
items.  Either way, htmlpp needs a blank line before the table.  A
table item looks like this:
<PRE>Some_word:    Followed by some explanation
               which can come on several lines.
</PRE>

<P>The first column must be a single word - if you want several words,
use underlines.  Htmlpp replaces these by spaces.  The explanation can
come on several lines, which <EM>must</EM> be indented by one or more
spaces.

<H4><A NAME="TOC32">Figures and Images</A></H4>
<P>To insert a figure, use one of these conventions:
<PRE>[Figure <EM>filename</EM>: caption]
[Figure "<EM>filename</EM>": caption]
</PRE>

<P>Htmlpp inserts a figure caption, numbering the figures in a document
from 1 upwards.  The caption is followed by an &lt;IMG&gt; tag to display
the file. You can use a URI (a path) as the filename, or an URL (with a
host name specifier); you must put an URL in quotes.  My preference is
to put image files locally with the HTML files, and use a simple
filename without a path.  This is just easier to manage and lets you
put the HTML files plus images in any directory.  If htmlpp can find
the image you specify, and it's a .GIF or .JPG file, it will insert
the WIDTH= and HEIGHT= tags automatically.

<P>To insert a plain image, omit the 'Figure' keyword.  For example,
these are all examples of valid images:
<PRE>[Figure somefile.gif: caption]
[somefile.gif: caption]
[Figure somefile.gif]
[somefile.gif]
</PRE>

<H4><A NAME="TOC33">Hyperlinks</A></H4>

<P>If you use &lt;name@address&gt;, this is converted into a mailto:
URL hyperlink.  If you use &lt;http://address/document&gt; -- or any
other URL -- this is converted into a hyperlink as well.  You can follow the
URL by ':description' if you like, e.g. &lt;http://www.imatix.com:iMatix
Corporation's Site&gt;.  You can also refer to local files using the syntax
&lt;/localfile[:description]&gt;.

<P>Htmlpp does not presently allow links within the document or to
other documents.

<H4><A NAME="TOC34">Special Characters</A></H4>

<P>Since you're not typing HTML, htmlpp replaces &lt;, &gt; and &amp;
by HTML metacharacters.  &lt; and &gt; are used to indicate hyperlinks.

<A NAME="intrinsic">&nbsp;</A>
<H3><A NAME="TOC35">Htmlpp Intrinsic Functions</A></H3>

<P>Htmlpp provides a number of intrinsic functions that you can
use in your text.  The syntax for using an intrinsic function is:
<PRE>&function-name(arguments)</PRE>

<TABLE>
<TR><TH>This function:              <TH>Does this:
<TR><TD>&<A href="index3.htm#date">date</A>("picture", date)     <TD>Format specified date using picture
<TR><TD>&<A href="index3.htm#date">date</A>("picture", date, lc) <TD>Format specified date using picture
and language code.
<TR><TD>&<A href="index3.htm#date">date</A>("picture")           <TD>Format current date using picture
<TR><TD>&<A href="index3.htm#date">date</A>()                    <TD>Return current date value
<TR><TD>&<A href="index3.htm#time">time</A>()                    <TD>Format current time as hh:mm:ss
<TR><TD>&<A href="index3.htm#week_day">week day</A>([date])          <TD>Get day of week, 0=Sunday, 6=Saturda
<TR><TD>&<A href="index3.htm#year_week">year week</A>([date])         <TD>Get week of year, 1 is first full we
<TR><TD>&<A href="index3.htm#julian_date">julian date</A>([date])       <TD>Get Julian date for date
<TR><TD>&<A href="index3.htm#lillian_date">lillian date</A>([date])      <TD>Get Lillian date for date
<TR><TD>&<A href="index3.htm#date_to_days">date to days</A>(date)        <TD>Convert yyyymmdd to Lillian date
<TR><TD>&<A href="index3.htm#days_to_date">days to date</A>(days)        <TD>Convert Lillian date to yyyymmdd
<TR><TD>&<A href="index3.htm#future_date">future date</A>(days,[date])  <TD>Calculate future date
<TR><TD>&<A href="index3.htm#past_date">past date</A>(days,[date])    <TD>Calculate past date
<TR><TD>&<A href="index3.htm#date_diff">date diff</A>(date1,date2)    <TD>Calculate differences between dates
<TR><TD>&<A href="index3.htm#image_height">image height</A>("image.ext") <TD>Get image height (GIF, JPEG)
<TR><TD>&<A href="index3.htm#image_width">image width</A>("image.ext")  <TD>Get image width (GIF, JPEG)
<TR><TD>&<A href="index3.htm#file_size">file size</A>("filename",arg) <TD>Get size of file: optional arg K or
<TR><TD>&<A href="index3.htm#file_date">file date</A>("filename")     <TD>Get date of file
<TR><TD>&<A href="index3.htm#file_time">file time</A>("filename")     <TD>Get time of file as hh:mm:ss
<TR><TD>&<A href="index3.htm#normalise">normalise</A>("filename")     <TD>Normalise filename to UNIX format
<TR><TD>&<A href="index3.htm#system">system</A>("command")         <TD>Get result of some system utility
<TR><TD>&<A href="index3.htm#upper">upper</A>("string")           <TD>Convert string to uppercase text
<TR><TD>&<A href="index3.htm#lower">lower</A>("string")           <TD>Convert string to lowercase text
<TR><TD>&<A href="index3.htm#pageref">pageref</A>("page","title")   <TD>Build link for page index
<TR><TD>&<A href="index3.htm#relpath">relpath</A>("to")             <TD>Get relative path from current document-&gt;to
<TR><TD>&<A href="index3.htm#relpath">relpath</A>(["from"],"to")    <TD>Get relative path from-&gt;to
</TABLE>


<A NAME="date">&nbsp;</A>
<H4><A NAME="TOC36">The &date Function</A></H4>
<P>Syntax:
<PRE>&date(<I>picture</I>, <I>value</I>)
&date(<I>picture</I>, <I>value</I>, </I>language</I>)
&date(<I>picture</I>)
&date()
</PRE>

<P>Without a picture, returns the current date. With a picture, formats the
current date according to a picture that you specify. You can optionally
supply a date value in the standard 8-digit format; YYYYMMDD (as returned by
&date()), or use 0 to indicate today's date. You can optionally follow the
picture and value by a language code; the values currently accepted are "es"
for Spanish, "fr" for French, and "dk" for Danish.
Anything else is taken to mean English. If no language is specified, $(LANG)
is used by default. The picture can consist of any mixture of these elements:
<TABLE>
<TR><TD>cc   <TD>century 2 digits, 01-99
<TR><TD>y    <TD>day of year, 1-366
<TR><TD>yy   <TD>year 2 digits, 00-99
<TR><TD>yyyy <TD>year 4 digits, 100-9999
<TR><TD>m    <TD>month, 1-12
<TR><TD>mm   <TD>month, 01-12
<TR><TD>mmm  <TD>month, 3 letters
<TR><TD>mmmm <TD>month, full name
<TR><TD>MMM  <TD>month, 3 letters, ucase
<TR><TD>MMMM <TD>month, full name, ucase
<TR><TD>d    <TD>day, 1-31
<TR><TD>dd   <TD>day, 01-31
<TR><TD>ddd  <TD>day of week, Sun-Sat
<TR><TD>dddd <TD>day of week, Sunday-Saturday
<TR><TD>DDD  <TD>day of week, SUN-SAT
<TR><TD>DDDD <TD>day of week, SUNDAY-SATURDAY
<TR><TD>w    <TD>day of week, 1-7 (1=Sunday)
<TR><TD>ww   <TD>week of year, 1-53
<TR><TD>q    <TD>year quarter, 1-4
<TR><TD>\x   <TD>literal character x
<TR><TD>other<TD>literal character
</TABLE>

<P>Examples:
<PRE>
.echo &date()             --> Nov 13, 99
.echo &date('mm d, yy')   --> Dec 2, 98
.echo &date('d mmm, yy')  --> 2 Dec, 98
.echo &date("yymd")       --> 9812 2
.echo &date("yyyymmdd")   --> 19981202
.echo &date("d \de mmmm \de yyyy", 0, "es")  --> today's date in Spanish
</PRE>

<A NAME="time">&nbsp;</A>
<H4><A NAME="TOC37">The &time Function</A></H4>
<P>Syntax:
<PRE>&time()
</PRE>
<P>Formats the current time in the same way as the $(TIME) symbol.
The difference is that $(TIME) is set when htmlpp starts working;
&time() reflects the current time.

<A NAME="week_day">&nbsp;</A>
<H4><A NAME="TOC38">The &week_day Function</A></H4>
<P>Syntax:
<PRE>&week_day()
&week_day(<I>date</I>)
</PRE>
<P>Returns the day of the week for the specified date, or for the current
date if no argument is given.  Day 0 is Sunday; day 6 is Saturday.

<A NAME="year_week">&nbsp;</A>
<H4><A NAME="TOC39">The &year_week Function</A></H4>
<P>Syntax:
<PRE>&year_week()
&year_week(<I>date</I>)
</PRE>
<P>Returns the week of the year for the specified date, or for the current
date if no argument is given.  Week 1 is the first full week, starting with
a Sunday.

<A NAME="julian_date">&nbsp;</A>
<H4><A NAME="TOC40">The &julian_date Function</A></H4>
<P>Syntax:
<PRE>&julian_date()
&julian_date(<I>date</I>)
</PRE>
<P>Returns the Julian date for the specified date, or for the current
date if no argument is given.  Day 1 is January 1.

<A NAME="lillian_date">&nbsp;</A>
<H4><A NAME="TOC41">The &lillian_date Function</A></H4>
<P>Syntax:
<PRE>&lillian_date()
&lillian_date(<I>date</I>)
</PRE>
<P>Returns the Lillian date for the specified date, or for the current
date if no argument is given.  This is the number of days since a starting
(but unspecified) epoch (which in fact is around 1582).

<A NAME="date_to_days">&nbsp;</A>
<H4><A NAME="TOC42">The &date_to_days Function</A></H4>
<P>Syntax:
<PRE>&date_to_days(<I>date</I>)
</PRE>
<P>Returns the Lillian date for the specified date.  This function is
really a the same as &lillian_date() except that you must supply a
date argument.  It's provided for orthogonality with &days_to_date().

<A NAME="days_to_date">&nbsp;</A>
<H4><A NAME="TOC43">The &days_to_date Function</A></H4>
<P>Syntax:
<PRE>&days_to_date(<I>days</I>)
</PRE>
<P>Converts a Lillian date back into a normal date in the form
yyyymmdd.  You can use this function (in combination with the
reverse function, &date_to_days()) to calculate past and future
dates.

<A NAME="future_date">&nbsp;</A>
<H4><A NAME="TOC44">The &future_date Function</A></H4>
<P>Syntax:
<PRE>&future_date(<I>days</I>)
&future_date(<I>days</I>,<I>date</I>)
</PRE>
<P>Calculates a date at some point in the future.  For instance,
19981109 will produce tomorrow's date.  If the date argument is
not provided, calculates from today.

<A NAME="past_date">&nbsp;</A>
<H4><A NAME="TOC45">The &past_date Function</A></H4>
<P>Syntax:
<PRE>&past_date(<I>days</I>)
&past_date(<I>days</I>,<I>date</I>)
</PRE>
<P>Calculates a date at some point in the past.  For instance,
19981107 will produce yesterday's date.  If the date argument is
not provided, calculates from today.

<A NAME="date_diff">&nbsp;</A>
<H4><A NAME="TOC46">The &date_diff Function</A></H4>
<P>Syntax:
<PRE>&date_diff(<I>date</I>)
&date_diff(<I>date1</I>,<I>date2</I>)
</PRE>
<P>Calculates the difference between two dates, in days.  The calculation is
date1 - date2.  If date2 is not supplied, calculates using today, and will
therefore return a positive value if date is in the future, and a negative
value if date is in the past.

<A NAME="image_width">&nbsp;</A>
<H4><A NAME="TOC47">The &image_width Function</A></H4>
<P>Syntax:
<PRE>&image_width(<I>filename</I>)
</PRE>
<P>Returns the width of the specified image, which can be a GIF or
JPEG file, in any of the common formats (including progressive
encoding).  The width is returned in pixels.

<A NAME="image_height">&nbsp;</A>
<H4><A NAME="TOC48">The &image_height Function</A></H4>
<P>Syntax:
<PRE>&image_height(<I>filename</I>)
</PRE>
<P>Returns the height of the specified image, which can be a GIF or
JPEG file, in any of the common formats (including progressive
encoding).  The height is returned in pixels.

<A NAME="file_size">&nbsp;</A>
<H4><A NAME="TOC49">The &file_size Function</A></H4>
<P>Syntax:
<PRE>&file_size(<I>filename</I>)
&file_size(<I>filename</I>, K)
&file_size(<I>filename</I>, M)
</PRE>
<P>Returns the size of the specified file.  If the second argument is
K or M, calculates the size in Kb or Mb as appropriate.  Always returns
an integer value.

<A NAME="file_date">&nbsp;</A>
<H4><A NAME="TOC50">The &file_date Function</A></H4>
<P>Syntax:
<PRE>&file_date(<I>filename</I>)
</PRE>
<P>Returns the date of the specified file, as an 8-digit value, YYYYMMDD.

<A NAME="file_time">&nbsp;</A>
<H4><A NAME="TOC51">The &file_time Function</A></H4>
<P>Syntax:
<PRE>&file_time(<I>filename</I>)
</PRE>
<P>Returns the time of the specified file, as a string, HH:MM:SS.

<A NAME="normalise">&nbsp;</A>
<H4><A NAME="TOC52">The &normalise Function</A></H4>
<P>Syntax:
<PRE>&normalise(<I>filepath</I>)
</PRE>
<P>Returns the filepath in a UNIX-style format. You can use this, for
instance, under MS-DOS, when filenames taken from (e.g.) the environment
contain back slashes which can cause problems.  Replaces \ by / and
spaces by underlines.

<A NAME="system">&nbsp;</A>
<H4><A NAME="TOC53">The &system Function</A></H4>
<P>Syntax:
<PRE>&system(<I>string</I>)
</PRE>
<P>Returns the result of some system utility.  For instance:
<PRE>.define SERVER  http://&system("hostname")
</PRE>

<A NAME="upper">&nbsp;</A>
<H4><A NAME="TOC54">The &upper Function</A></H4>
<P>Syntax:
<PRE>&upper(<I>string</I>)
</PRE>
<P>Returns the string in uppercase letters.

<A NAME="lower">&nbsp;</A>
<H4><A NAME="TOC55">The &lower Function</A></H4>
<P>Syntax:
<PRE>&lower(<I>string</I>)
</PRE>
<P>Returns the string in lowercase letters.

<A NAME="pageref">&nbsp;</A>
<H4><A NAME="TOC56">The &pageref Function</A></H4>
<P>Syntax:
<PRE>&pageref(<I>"page"</I>,<I>"title"</I>)
</PRE>
Does the same as this htmlpp code:
.if "name" eq "index3.htm"
title
.else
&lt;A HREF="page"&gt;title&lt;/A&gt;
.endif
<P>This function strips-off any HTML tags that you put around the title text
when it uses it to build a link.  So, you can do this kind of thing, which I
often use to build an index in the page footer:
.block index_entry
&pageref("$(INDEX_PAGE)","&lt;EM&gt;$(INDEX_TITLE)&lt;/EM&gt;")
.endblock

<A NAME="relpath">&nbsp;</A>
<H4><A NAME="TOC57">The &relpath Function</A></H4>
<P>Syntax:
<PRE>&relpath([<I>"from"</I>], <I>"to"</I>)</PRE>
<P>Returns the relative path from 'from' to 'to'. If only one argument
is specified, the current HTML page is used as 'from'. For example:
<PRE>&relpath("john/peter/david/me.html","john/henry/you.html")</PRE>
would return "../../henry/you.html".  You can use this to create a web site
with pure relative references to other pages. Remember that you don't need
to use this function with $(*name) links if $(USE_RELPATH) is set to 1.
Note that if you use
relative references you can test and use the HTML pages on a local hard
disk as well as on the server without changes.

<H3><A NAME="TOC58">Multipass Processing</A></H3>

<P>Since version 2.00, htmlpp uses a multipass technique to allow
embedded blocks.  For example, you can place .include actions in
the header or footer blocks, or define your own blocks that have
.define, .page, and other actions.

<P>Htmlpp handles this using the following rules:
<OL>
<LI>.include actions are executed immediately.
<LI>.block actions are executed immediately.
<LI>.build actions are executed as soon as possible after the
first pass.  This allows htmlpp time to collect the document
titles, which it needs to build the table of contents.
<LI>.if ... .else ... .endif actions are handled at once.
<LI>.page commands are handled in two stages; headers and
footers are built in the second pass, and individual page
files are built during the last pass.
<LI>Htmlpp will process the document (actually a temporary copy)
as many times as necessary, until all actions have been processed.
</OL>
<P>One consequence of this is that htmlpp needs a minimum of 3
passes to fully process a document, one to collect all the titles;
one to insert page headers and footers, and a last one to break the
text into individual pages.  If any genius can help me reduce this
to two (or one!) pass, go ahead.

<P>The upside is that you can do really funky stuff in headers
and footers: for instance, the htmlpp pages build a document
index in the footer, switching hyperlinks on and off to indicate
the current page in the index.

<H3><A NAME="TOC59">Multipass Debugging</A></H3>

<P>To see what htmlpp is doing with its passes, use the -debug
option, like this:
<PRE>htmlpp -debug <EM>filename</EM></PRE>
This leaves a number of .wrk files lying around; these contain
the result of each pass.

<H3><A NAME="TOC60">Other Things to Know</A></H3>

<UL>
<LI>If you end a line with '\', it will be output to the final HTML file
without a trailing newline (and without the '\').
</UL>

<HR><TABLE WIDTH=100%><TR><TD ALIGN=LEFT WIDTH=60%>
 | <A href="index.htm">&lt;&lt;</A> | <A href="index2.htm">&lt;</A>
 | <A href="index4.htm">&gt;</A> | <A href="index5.htm">&gt;&gt;</A>
<BR><FONT SIZE=2>
| <A HREF="index.htm">htmlpp - The HTML Preprocessor</A>
| <A HREF="index1.htm">Installing Htmlpp</A>
| <A HREF="index2.htm">Getting Started</A>
| <EM>Htmlpp Reference</EM>
| <A HREF="index4.htm">Frequently Asked Questions</A>
| <A HREF="index5.htm">Other Information</A>
<TD ALIGN=RIGHT NOWRAP>
<A HREF="/index.htm">
<IMG SRC="im0096c.gif" WIDTH=96 HEIGHT=36 ALT="iMatix" BORDER=0>
</A>
<BR><FONT SIZE=2>Copyright &#169; 1996-97 iMatix</TABLE>
</BODY></HTML>
